// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: khutulun.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AgentClient is the client API for Agent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentClient interface {
	GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Version, error)
	ListHosts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Agent_ListHostsClient, error)
	AddHost(ctx context.Context, in *AddHost, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListNamespaces(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Agent_ListNamespacesClient, error)
	ListPackages(ctx context.Context, in *ListPackages, opts ...grpc.CallOption) (Agent_ListPackagesClient, error)
	ListPackageFiles(ctx context.Context, in *PackageIdentifier, opts ...grpc.CallOption) (Agent_ListPackageFilesClient, error)
	GetPackageFiles(ctx context.Context, in *GetPackageFiles, opts ...grpc.CallOption) (Agent_GetPackageFilesClient, error)
	SetPackageFiles(ctx context.Context, opts ...grpc.CallOption) (Agent_SetPackageFilesClient, error)
	RemovePackage(ctx context.Context, in *PackageIdentifier, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeployService(ctx context.Context, in *DeployService, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListResources(ctx context.Context, in *ListResources, opts ...grpc.CallOption) (Agent_ListResourcesClient, error)
	Interact(ctx context.Context, opts ...grpc.CallOption) (Agent_InteractClient, error)
}

type agentClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentClient(cc grpc.ClientConnInterface) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/khutulun.Agent/getVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) ListHosts(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Agent_ListHostsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[0], "/khutulun.Agent/listHosts", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentListHostsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_ListHostsClient interface {
	Recv() (*HostIdentifier, error)
	grpc.ClientStream
}

type agentListHostsClient struct {
	grpc.ClientStream
}

func (x *agentListHostsClient) Recv() (*HostIdentifier, error) {
	m := new(HostIdentifier)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) AddHost(ctx context.Context, in *AddHost, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/khutulun.Agent/addHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) ListNamespaces(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Agent_ListNamespacesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[1], "/khutulun.Agent/listNamespaces", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentListNamespacesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_ListNamespacesClient interface {
	Recv() (*Namespace, error)
	grpc.ClientStream
}

type agentListNamespacesClient struct {
	grpc.ClientStream
}

func (x *agentListNamespacesClient) Recv() (*Namespace, error) {
	m := new(Namespace)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) ListPackages(ctx context.Context, in *ListPackages, opts ...grpc.CallOption) (Agent_ListPackagesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[2], "/khutulun.Agent/listPackages", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentListPackagesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_ListPackagesClient interface {
	Recv() (*PackageIdentifier, error)
	grpc.ClientStream
}

type agentListPackagesClient struct {
	grpc.ClientStream
}

func (x *agentListPackagesClient) Recv() (*PackageIdentifier, error) {
	m := new(PackageIdentifier)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) ListPackageFiles(ctx context.Context, in *PackageIdentifier, opts ...grpc.CallOption) (Agent_ListPackageFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[3], "/khutulun.Agent/listPackageFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentListPackageFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_ListPackageFilesClient interface {
	Recv() (*PackageFile, error)
	grpc.ClientStream
}

type agentListPackageFilesClient struct {
	grpc.ClientStream
}

func (x *agentListPackageFilesClient) Recv() (*PackageFile, error) {
	m := new(PackageFile)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) GetPackageFiles(ctx context.Context, in *GetPackageFiles, opts ...grpc.CallOption) (Agent_GetPackageFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[4], "/khutulun.Agent/getPackageFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentGetPackageFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_GetPackageFilesClient interface {
	Recv() (*PackageContent, error)
	grpc.ClientStream
}

type agentGetPackageFilesClient struct {
	grpc.ClientStream
}

func (x *agentGetPackageFilesClient) Recv() (*PackageContent, error) {
	m := new(PackageContent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) SetPackageFiles(ctx context.Context, opts ...grpc.CallOption) (Agent_SetPackageFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[5], "/khutulun.Agent/setPackageFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentSetPackageFilesClient{stream}
	return x, nil
}

type Agent_SetPackageFilesClient interface {
	Send(*PackageContent) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type agentSetPackageFilesClient struct {
	grpc.ClientStream
}

func (x *agentSetPackageFilesClient) Send(m *PackageContent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *agentSetPackageFilesClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) RemovePackage(ctx context.Context, in *PackageIdentifier, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/khutulun.Agent/removePackage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) DeployService(ctx context.Context, in *DeployService, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/khutulun.Agent/deployService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) ListResources(ctx context.Context, in *ListResources, opts ...grpc.CallOption) (Agent_ListResourcesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[6], "/khutulun.Agent/listResources", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentListResourcesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_ListResourcesClient interface {
	Recv() (*ResourceIdentifier, error)
	grpc.ClientStream
}

type agentListResourcesClient struct {
	grpc.ClientStream
}

func (x *agentListResourcesClient) Recv() (*ResourceIdentifier, error) {
	m := new(ResourceIdentifier)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) Interact(ctx context.Context, opts ...grpc.CallOption) (Agent_InteractClient, error) {
	stream, err := c.cc.NewStream(ctx, &Agent_ServiceDesc.Streams[7], "/khutulun.Agent/interact", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentInteractClient{stream}
	return x, nil
}

type Agent_InteractClient interface {
	Send(*Interaction) error
	Recv() (*Interaction, error)
	grpc.ClientStream
}

type agentInteractClient struct {
	grpc.ClientStream
}

func (x *agentInteractClient) Send(m *Interaction) error {
	return x.ClientStream.SendMsg(m)
}

func (x *agentInteractClient) Recv() (*Interaction, error) {
	m := new(Interaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AgentServer is the server API for Agent service.
// All implementations must embed UnimplementedAgentServer
// for forward compatibility
type AgentServer interface {
	GetVersion(context.Context, *emptypb.Empty) (*Version, error)
	ListHosts(*emptypb.Empty, Agent_ListHostsServer) error
	AddHost(context.Context, *AddHost) (*emptypb.Empty, error)
	ListNamespaces(*emptypb.Empty, Agent_ListNamespacesServer) error
	ListPackages(*ListPackages, Agent_ListPackagesServer) error
	ListPackageFiles(*PackageIdentifier, Agent_ListPackageFilesServer) error
	GetPackageFiles(*GetPackageFiles, Agent_GetPackageFilesServer) error
	SetPackageFiles(Agent_SetPackageFilesServer) error
	RemovePackage(context.Context, *PackageIdentifier) (*emptypb.Empty, error)
	DeployService(context.Context, *DeployService) (*emptypb.Empty, error)
	ListResources(*ListResources, Agent_ListResourcesServer) error
	Interact(Agent_InteractServer) error
	mustEmbedUnimplementedAgentServer()
}

// UnimplementedAgentServer must be embedded to have forward compatible implementations.
type UnimplementedAgentServer struct {
}

func (UnimplementedAgentServer) GetVersion(context.Context, *emptypb.Empty) (*Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedAgentServer) ListHosts(*emptypb.Empty, Agent_ListHostsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListHosts not implemented")
}
func (UnimplementedAgentServer) AddHost(context.Context, *AddHost) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddHost not implemented")
}
func (UnimplementedAgentServer) ListNamespaces(*emptypb.Empty, Agent_ListNamespacesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListNamespaces not implemented")
}
func (UnimplementedAgentServer) ListPackages(*ListPackages, Agent_ListPackagesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListPackages not implemented")
}
func (UnimplementedAgentServer) ListPackageFiles(*PackageIdentifier, Agent_ListPackageFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListPackageFiles not implemented")
}
func (UnimplementedAgentServer) GetPackageFiles(*GetPackageFiles, Agent_GetPackageFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetPackageFiles not implemented")
}
func (UnimplementedAgentServer) SetPackageFiles(Agent_SetPackageFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method SetPackageFiles not implemented")
}
func (UnimplementedAgentServer) RemovePackage(context.Context, *PackageIdentifier) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePackage not implemented")
}
func (UnimplementedAgentServer) DeployService(context.Context, *DeployService) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployService not implemented")
}
func (UnimplementedAgentServer) ListResources(*ListResources, Agent_ListResourcesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListResources not implemented")
}
func (UnimplementedAgentServer) Interact(Agent_InteractServer) error {
	return status.Errorf(codes.Unimplemented, "method Interact not implemented")
}
func (UnimplementedAgentServer) mustEmbedUnimplementedAgentServer() {}

// UnsafeAgentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServer will
// result in compilation errors.
type UnsafeAgentServer interface {
	mustEmbedUnimplementedAgentServer()
}

func RegisterAgentServer(s grpc.ServiceRegistrar, srv AgentServer) {
	s.RegisterService(&Agent_ServiceDesc, srv)
}

func _Agent_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/khutulun.Agent/getVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).GetVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_ListHosts_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).ListHosts(m, &agentListHostsServer{stream})
}

type Agent_ListHostsServer interface {
	Send(*HostIdentifier) error
	grpc.ServerStream
}

type agentListHostsServer struct {
	grpc.ServerStream
}

func (x *agentListHostsServer) Send(m *HostIdentifier) error {
	return x.ServerStream.SendMsg(m)
}

func _Agent_AddHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).AddHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/khutulun.Agent/addHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).AddHost(ctx, req.(*AddHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_ListNamespaces_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).ListNamespaces(m, &agentListNamespacesServer{stream})
}

type Agent_ListNamespacesServer interface {
	Send(*Namespace) error
	grpc.ServerStream
}

type agentListNamespacesServer struct {
	grpc.ServerStream
}

func (x *agentListNamespacesServer) Send(m *Namespace) error {
	return x.ServerStream.SendMsg(m)
}

func _Agent_ListPackages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPackages)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).ListPackages(m, &agentListPackagesServer{stream})
}

type Agent_ListPackagesServer interface {
	Send(*PackageIdentifier) error
	grpc.ServerStream
}

type agentListPackagesServer struct {
	grpc.ServerStream
}

func (x *agentListPackagesServer) Send(m *PackageIdentifier) error {
	return x.ServerStream.SendMsg(m)
}

func _Agent_ListPackageFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PackageIdentifier)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).ListPackageFiles(m, &agentListPackageFilesServer{stream})
}

type Agent_ListPackageFilesServer interface {
	Send(*PackageFile) error
	grpc.ServerStream
}

type agentListPackageFilesServer struct {
	grpc.ServerStream
}

func (x *agentListPackageFilesServer) Send(m *PackageFile) error {
	return x.ServerStream.SendMsg(m)
}

func _Agent_GetPackageFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetPackageFiles)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).GetPackageFiles(m, &agentGetPackageFilesServer{stream})
}

type Agent_GetPackageFilesServer interface {
	Send(*PackageContent) error
	grpc.ServerStream
}

type agentGetPackageFilesServer struct {
	grpc.ServerStream
}

func (x *agentGetPackageFilesServer) Send(m *PackageContent) error {
	return x.ServerStream.SendMsg(m)
}

func _Agent_SetPackageFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServer).SetPackageFiles(&agentSetPackageFilesServer{stream})
}

type Agent_SetPackageFilesServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*PackageContent, error)
	grpc.ServerStream
}

type agentSetPackageFilesServer struct {
	grpc.ServerStream
}

func (x *agentSetPackageFilesServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *agentSetPackageFilesServer) Recv() (*PackageContent, error) {
	m := new(PackageContent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Agent_RemovePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageIdentifier)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).RemovePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/khutulun.Agent/removePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).RemovePackage(ctx, req.(*PackageIdentifier))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_DeployService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).DeployService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/khutulun.Agent/deployService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).DeployService(ctx, req.(*DeployService))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_ListResources_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListResources)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).ListResources(m, &agentListResourcesServer{stream})
}

type Agent_ListResourcesServer interface {
	Send(*ResourceIdentifier) error
	grpc.ServerStream
}

type agentListResourcesServer struct {
	grpc.ServerStream
}

func (x *agentListResourcesServer) Send(m *ResourceIdentifier) error {
	return x.ServerStream.SendMsg(m)
}

func _Agent_Interact_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServer).Interact(&agentInteractServer{stream})
}

type Agent_InteractServer interface {
	Send(*Interaction) error
	Recv() (*Interaction, error)
	grpc.ServerStream
}

type agentInteractServer struct {
	grpc.ServerStream
}

func (x *agentInteractServer) Send(m *Interaction) error {
	return x.ServerStream.SendMsg(m)
}

func (x *agentInteractServer) Recv() (*Interaction, error) {
	m := new(Interaction)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Agent_ServiceDesc is the grpc.ServiceDesc for Agent service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Agent_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "khutulun.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getVersion",
			Handler:    _Agent_GetVersion_Handler,
		},
		{
			MethodName: "addHost",
			Handler:    _Agent_AddHost_Handler,
		},
		{
			MethodName: "removePackage",
			Handler:    _Agent_RemovePackage_Handler,
		},
		{
			MethodName: "deployService",
			Handler:    _Agent_DeployService_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "listHosts",
			Handler:       _Agent_ListHosts_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listNamespaces",
			Handler:       _Agent_ListNamespaces_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listPackages",
			Handler:       _Agent_ListPackages_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listPackageFiles",
			Handler:       _Agent_ListPackageFiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getPackageFiles",
			Handler:       _Agent_GetPackageFiles_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "setPackageFiles",
			Handler:       _Agent_SetPackageFiles_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "listResources",
			Handler:       _Agent_ListResources_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "interact",
			Handler:       _Agent_Interact_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "khutulun.proto",
}

// DelegateClient is the client API for Delegate service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DelegateClient interface {
	ListResources(ctx context.Context, in *DelegateListResources, opts ...grpc.CallOption) (Delegate_ListResourcesClient, error)
	ProcessService(ctx context.Context, in *ProcessService, opts ...grpc.CallOption) (*ProcessServiceResult, error)
	Interact(ctx context.Context, opts ...grpc.CallOption) (Delegate_InteractClient, error)
}

type delegateClient struct {
	cc grpc.ClientConnInterface
}

func NewDelegateClient(cc grpc.ClientConnInterface) DelegateClient {
	return &delegateClient{cc}
}

func (c *delegateClient) ListResources(ctx context.Context, in *DelegateListResources, opts ...grpc.CallOption) (Delegate_ListResourcesClient, error) {
	stream, err := c.cc.NewStream(ctx, &Delegate_ServiceDesc.Streams[0], "/khutulun.Delegate/listResources", opts...)
	if err != nil {
		return nil, err
	}
	x := &delegateListResourcesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Delegate_ListResourcesClient interface {
	Recv() (*ResourceIdentifier, error)
	grpc.ClientStream
}

type delegateListResourcesClient struct {
	grpc.ClientStream
}

func (x *delegateListResourcesClient) Recv() (*ResourceIdentifier, error) {
	m := new(ResourceIdentifier)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *delegateClient) ProcessService(ctx context.Context, in *ProcessService, opts ...grpc.CallOption) (*ProcessServiceResult, error) {
	out := new(ProcessServiceResult)
	err := c.cc.Invoke(ctx, "/khutulun.Delegate/processService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *delegateClient) Interact(ctx context.Context, opts ...grpc.CallOption) (Delegate_InteractClient, error) {
	stream, err := c.cc.NewStream(ctx, &Delegate_ServiceDesc.Streams[1], "/khutulun.Delegate/interact", opts...)
	if err != nil {
		return nil, err
	}
	x := &delegateInteractClient{stream}
	return x, nil
}

type Delegate_InteractClient interface {
	Send(*Interaction) error
	Recv() (*Interaction, error)
	grpc.ClientStream
}

type delegateInteractClient struct {
	grpc.ClientStream
}

func (x *delegateInteractClient) Send(m *Interaction) error {
	return x.ClientStream.SendMsg(m)
}

func (x *delegateInteractClient) Recv() (*Interaction, error) {
	m := new(Interaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DelegateServer is the server API for Delegate service.
// All implementations must embed UnimplementedDelegateServer
// for forward compatibility
type DelegateServer interface {
	ListResources(*DelegateListResources, Delegate_ListResourcesServer) error
	ProcessService(context.Context, *ProcessService) (*ProcessServiceResult, error)
	Interact(Delegate_InteractServer) error
	mustEmbedUnimplementedDelegateServer()
}

// UnimplementedDelegateServer must be embedded to have forward compatible implementations.
type UnimplementedDelegateServer struct {
}

func (UnimplementedDelegateServer) ListResources(*DelegateListResources, Delegate_ListResourcesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListResources not implemented")
}
func (UnimplementedDelegateServer) ProcessService(context.Context, *ProcessService) (*ProcessServiceResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessService not implemented")
}
func (UnimplementedDelegateServer) Interact(Delegate_InteractServer) error {
	return status.Errorf(codes.Unimplemented, "method Interact not implemented")
}
func (UnimplementedDelegateServer) mustEmbedUnimplementedDelegateServer() {}

// UnsafeDelegateServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DelegateServer will
// result in compilation errors.
type UnsafeDelegateServer interface {
	mustEmbedUnimplementedDelegateServer()
}

func RegisterDelegateServer(s grpc.ServiceRegistrar, srv DelegateServer) {
	s.RegisterService(&Delegate_ServiceDesc, srv)
}

func _Delegate_ListResources_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DelegateListResources)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DelegateServer).ListResources(m, &delegateListResourcesServer{stream})
}

type Delegate_ListResourcesServer interface {
	Send(*ResourceIdentifier) error
	grpc.ServerStream
}

type delegateListResourcesServer struct {
	grpc.ServerStream
}

func (x *delegateListResourcesServer) Send(m *ResourceIdentifier) error {
	return x.ServerStream.SendMsg(m)
}

func _Delegate_ProcessService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessService)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DelegateServer).ProcessService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/khutulun.Delegate/processService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DelegateServer).ProcessService(ctx, req.(*ProcessService))
	}
	return interceptor(ctx, in, info, handler)
}

func _Delegate_Interact_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DelegateServer).Interact(&delegateInteractServer{stream})
}

type Delegate_InteractServer interface {
	Send(*Interaction) error
	Recv() (*Interaction, error)
	grpc.ServerStream
}

type delegateInteractServer struct {
	grpc.ServerStream
}

func (x *delegateInteractServer) Send(m *Interaction) error {
	return x.ServerStream.SendMsg(m)
}

func (x *delegateInteractServer) Recv() (*Interaction, error) {
	m := new(Interaction)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Delegate_ServiceDesc is the grpc.ServiceDesc for Delegate service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Delegate_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "khutulun.Delegate",
	HandlerType: (*DelegateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "processService",
			Handler:    _Delegate_ProcessService_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "listResources",
			Handler:       _Delegate_ListResources_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "interact",
			Handler:       _Delegate_Interact_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "khutulun.proto",
}
